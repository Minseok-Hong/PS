#include <stdio.h>
#pragma warning(disable:4996)

void input();
int findMax();
void init();
void VisitInit();
int check(int y, int x);
void printftmp();

int n;
int map[22][22];
int tmpMap[22][22];
int visit[22][22] = {0};

int dirY[4] = { 0,0,1,-1 };
int dirX[4] = { 1,-1,0,0 };
int nextX, nextY;

void go(int y, int x) {
	
	int index;

	if (x == -1) {//왼쪽으로 이동하는 경우

		for (int i = 0; i < n; i++) { // 축을 따라 위에서 부터 차례대로 민다.
			
			index = 0;
			
			while (1) {
				//printf("(%d,%d)\n", i, index);
				//printftmp();

				if (index == n) {
					break;
				}
				if (tmpMap[i][index] != 0) {//만약 빈칸이 아니면
					nextX = index - 1;
					if (check(i, nextX) == 0) {//만약 다음이 벽이면 
						index++;
						continue;
					}
					else {//이동할 경로가 빈칸인경우 || 빈칸이 아닌경우(같은경우, 다른경우)
						if (tmpMap[i][nextX] == 0) {//이동할 경로가 빈칸인경우
							tmpMap[i][nextX] = tmpMap[i][index];
							tmpMap[i][index] = 0;
							index = nextX;

						}
						else {//빈칸이 아닌경우
							if (tmpMap[i][index] == tmpMap[i][nextX] && visit[i][nextX] == 0) {//같은경우
								tmpMap[i][nextX] = tmpMap[i][nextX] * 2;
								tmpMap[i][index] = 0;
								
								visit[i][nextX] = 1;
								//index--;
							}
							else { //다른경우
								index++;
							}
							
						}
						
					}
				}
				else {//빈칸이면 다음을 찾자
					index++;
				}
				//index++;
			}
		}

	}
	else if (x == 1) {//오른쪽으로 이동하는 경우

		for (int i = 0; i < n; i++) { // 축을 따라 위에서 부터 차례대로 민다.

			index = n-1;

			while (1) {
				//printftmp();

				if (index == -1) {
					break;
				}
				if (tmpMap[i][index] != 0) {//만약 빈칸이 아니면
					nextX = index + 1;
					if (check(i, nextX) == 0) {//만약 다음이 벽이면 
						index--;
						continue;
					}
					else {//이동할 경로가 빈칸인경우 || 빈칸이 아닌경우(같은경우, 다른경우)
						if (tmpMap[i][nextX] == 0) {//이동할 경로가 빈칸인경우
							tmpMap[i][nextX] = tmpMap[i][index];
							tmpMap[i][index] = 0;
							index = nextX;
						}
						else {//빈칸이 아닌경우
							if (tmpMap[i][index] == tmpMap[i][nextX] && visit[i][nextX] ==0) {//같은경우
								tmpMap[i][nextX] = tmpMap[i][nextX] * 2;
								tmpMap[i][index] = 0;

								visit[i][nextX] = 1;
								//index--;
							}
							else { //다른경우
								index--;
							}
						}
					}
				}
				else {//빈칸이면 다음을 찾자
					index--;
				}
			}
		}
	}
	else if (y == -1) {//위로로 이동하는 경우

		for (int i = 0; i < n; i++) { // 축을 따라 위에서 부터 차례대로 민다.

			index = 0;

			while (1) {
				//printf("(%d,%d)\n", i, index);
				//printftmp();

				if (index == n) {
					break;
				}
				if (tmpMap[index][i] != 0) {//만약 빈칸이 아니면
					nextX = index - 1;
					if (check(nextX,i) == 0) {//만약 다음이 벽이면 
						index++;
						continue;
					}
					else {//이동할 경로가 빈칸인경우 || 빈칸이 아닌경우(같은경우, 다른경우)
						if (tmpMap[nextX][i] == 0) {//이동할 경로가 빈칸인경우
							tmpMap[nextX][i] = tmpMap[index][i];
							tmpMap[index][i] = 0;
							index = nextX;

						}
						else {//빈칸이 아닌경우
							if (tmpMap[index][i] == tmpMap[nextX][i] && visit[nextX][i] == 0) {//같은경우
								tmpMap[nextX][i] = tmpMap[nextX][i] * 2;
								tmpMap[index][i] = 0;
								
								visit[nextX][i] = 1;
								//index--;
							}
							else { //다른경우
								index++;
							}

						}

					}
				}
				else {//빈칸이면 다음을 찾자
					index++;
				}
				//index++;
			}
		}

	}
	else if (y == 1) {//아래로 이동하는 경우

		for (int i = 0; i < n; i++) { // 축을 따라 위에서 부터 차례대로 민다.

			index = n-1;

			while (1) {
				//printf("(%d,%d)\n", i, index);
				//printftmp();

				if (index == -1) {
					break;
				}
				if (tmpMap[index][i] != 0) {//만약 빈칸이 아니면
					nextX = index + 1;
					if (check(nextX, i) == 0) {//만약 다음이 벽이면 
						index--;
						continue;
					}
					else {//이동할 경로가 빈칸인경우 || 빈칸이 아닌경우(같은경우, 다른경우)
						if (tmpMap[nextX][i] == 0) {//이동할 경로가 빈칸인경우
							tmpMap[nextX][i] = tmpMap[index][i];
							tmpMap[index][i] = 0;
							index = nextX;

						}
						else {//빈칸이 아닌경우
							if (tmpMap[index][i] == tmpMap[nextX][i] && visit[nextX][i] == 0) {//같은경우
								tmpMap[nextX][i] = tmpMap[nextX][i] * 2;
								tmpMap[index][i] = 0;
								visit[nextX][i] = 1;
							}
							else { //다른경우
								index--;
							}
						}
					}
				}
				else {//빈칸이면 다음을 찾자
					index--;
				}
			}
		}

	}

}
int main()
{
	int result=0;
	int tmpResult=0;
	input();
	
	for (int i = 0; i < 4; i++) {
		for (int j= 0; j< 4; j++) {
			for (int k = 0; k< 4; k++) {
				for (int l= 0; l< 4; l++) {
					for (int m= 0; m< 4; m++) {
					
						go(dirY[i], dirX[i]);
						VisitInit();
						go(dirY[j], dirX[j]);
						VisitInit();
						go(dirY[k], dirX[k]);
						VisitInit();
						go(dirY[l], dirX[l]);
						VisitInit();
						go(dirY[m], dirX[m]);
						VisitInit();

						//printftmp();

						tmpResult = findMax();
						if (result < tmpResult) {
							result = tmpResult;
							//printftmp();
						}


						init();

					}
				}
			}
		}
	}
	printf("%d",result);
	
}

int check(int y, int x) {

	if (y >= 0 && y < n && x >= 0 && x < n) {
		return 1;
	}
	else {
		return 0;
	}
}

int findMax() {

	int max = 0;

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (tmpMap[i][j] > max) {
				max = tmpMap[i][j];
			}
			//tmpMap[i][j] = map[i][j];
		}
	}
	return max;

}

void init() {

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			tmpMap[i][j] = map[i][j];
		}
	}


}
void VisitInit() {

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			visit[i][j] = 0;
		}
	}


}

void printftmp()
{
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			printf("%d ", tmpMap[i][j]);
		}
		printf("\n");
	}
	printf("\n\n");

}
void input() {

	scanf("%d", &n);

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			scanf("%d", &map[i][j]);
			tmpMap[i][j] = map[i][j];
		}
	}
}


/*

4
8 8 8 8 
2 2 2 2
1 1 1 1 
1 1 1 1



[#1]


2
16 0
0 0

답 : 16


[#2]

7
2 2 2 2 2 2 2
2 0 2 2 2 2 2
2 0 2 2 2 2 2
2 0 2 2 2 2 2
2 2 2 0 2 2 2
2 2 2 2 2 2 0
2 2 2 2 2 2 0

답 : 32


[#3]

10
0 0 64 32 32 0 0 0 0 0
0 32 32 64 0 0 0 0 0 0
0 0 128 0 0 0 0 0 0 0
64 64 128 0 0 0 0 0 0 0
0 0 64 32 32 0 0 0 0 0
0 32 32 64 0 0 0 0 0 0
0 0 128 0 0 0 0 0 0 0
64 64 128 0 0 0 0 0 0 0
128 32 2 4 0 0 0 0 0 0
0 0 128 0 0 0 0 0 0 0

답 : 1024


[#4]

20
0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1
1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0
0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0
1 0 4 0 1 0 4 0 1 0 4 0 1 0 4 0 1 0 4 0
0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1
1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0
0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0
1 0 0 0 1 0 4 0 1 0 4 0 1 0 4 0 1 0 4 0
0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1
1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0
0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0
1 0 0 0 1 0 4 0 1 0 4 0 1 0 4 0 1 0 4 0
0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1
1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0
0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0
1 0 0 0 1 0 4 0 1 0 4 0 1 0 4 0 1 0 4 0
0 0 8 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1
1 3 8 0 1 3 0 0 1 3 0 0 1 3 0 0 1 3 0 0
0 2 4 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0
1 0 4 0 1 0 4 0 1 0 4 0 1 0 4 0 1 0 4 0

답 : 32


[#5]

20

20
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024
1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024 1024

답:32768

16
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

16
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1

10
16 16 8 32 32 0 0 8 8 8
16 0 0 0 0 8 0 0 0 16
0 0 0 0 0 0 0 0 0 2
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
-> 64

*/